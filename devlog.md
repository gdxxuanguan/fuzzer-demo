## 项目简介
本项目旨在开发一个简化版的覆盖率引导的变异式模糊测试工具，参考 AFL++。工具包含以下主要组件：

1. 插装组件（使用 afl-cc 实现）
2. 测试执行组件
3. 执行结果监控组件
4. 变异组件
5. 种子排序组件
6. 能量调度组件
7. 评估组件

团队成员根据组件分工如下：

+ **邱凯旋**：种子排序组件和能量调度组件
+ **刘婕琦**：变异组件
+ **赵浩博**：执行结果监控组件
+ **刘文浩**：评估组件

## 进度安排
列项目的主要里程碑和预计完成时间如下：

| 里程碑 | 描述 | 开始日期 | 结束日期 |
| --- | --- | --- | --- |
| 学习 AFL++ | 学习 AFL++ 的使用方法和插装原理 | 2024-10-25 | 2024-11-04 |
| 系统设计与模块划分 | 设计系统架构，划分各组件的功能和接口 | 2024-11-05 | 2024-11-11 |
| 代码编写阶段 | 按模块分工进行各组件的代码实现 | 2024-11-12 | 2024-12-02 |
| 简单测试阶段 | 对各组件进行单元测试和集成测试 | 2024-12-03 | 2024-12-09 |
| 24小时模糊测试运行 | 在所有 10 个模糊目标上运行 24 小时的模糊测试并收集数据 | 2024-12-10 | 2024-12-17 |
| 数据分析与结果收集 | 分析测试结果，绘制统计图表 | 2024-12-18 | 2024-12-22 |
| 文档编写与整理 | 完成开发日志和项目文档的编写 | 2024-12-23 | 2024-12-25 |


## 任务分配
### 邱凯旋：种子排序组件和能量调度组件
+ **种子排序组件**
    - 实现种子的优先级排序算法
    - 集成覆盖率信息进行排序
+ **能量调度组件**
    - 实现基于覆盖率的能量分配策略
    - 调整种子的执行优先级和能量值

### 刘婕琦：变异组件
+ **变异组件**
    - 实现基础变异算子（bitflip、arith、interest、havoc、splice）
    - 研究并实现基于语法/结构的高级变异算子，根据XML，JS等特殊结构生成符合语法的变异算子
    - 实现了变异组件工具类，提供自适应文件的变异功能

### 赵浩博：执行结果监控组件
+ 实现日志记录功能，记录覆盖率、执行速度等统计数据
+ 保存特殊测试用例，便于后续分析
+ 研究并理解 AFL++ 覆盖率信息的记录与传递机制
+ 实现与其他组件的数据交互，确保数据的实时监控与记录

### 刘文浩：评估组件
+ 实现统计图表的生成（覆盖率曲线图）
+ 开发数据分析脚本，处理和分析模糊测试数据
+ 绘制和汇总10个模糊目标的测试结果
+ 确保评估结果的准确性和可视化效果

## 开发进展
### 2024-10-25 至 2024-11-04
#### 全体成员
+ 学习 AFL++ 的基本使用方法
+ 阅读 AFL++ 插装原理相关文档

### 2024-11-05 至 2024-11-11
#### 邱凯旋
+ 设计种子排序组件的架构
+ 规划能量调度组件的功能需求

#### 刘婕琦
+ 设计变异组件的架构
+ 解决长时间变异中产生的程序崩溃

#### 赵浩博
+ 设计执行结果监控组件的架构
+ 确定日志记录和覆盖率监控的具体需求

#### 刘文浩
+ 设计评估组件的架构
+ 确定数据分析和统计图表的需求

### 2024-11-12 至 2024-12-02
#### 邱凯旋
+ 实现种子排序组件的优先级排序算法
+ 开发能量调度组件的初步功能

#### 刘婕琦
+ 实现基础变异算子（bitflip、arith）
+ 开发测试执行组件的子进程管理功能

#### 赵浩博
+ 实现基本的日志记录功能
+ 开发覆盖率数据的实时监控模块

#### 刘文浩
+ 开发数据分析脚本的初步框架
+ 实现覆盖率曲线图的生成工具

### 2024-12-03 至 2024-12-09
#### 邱凯旋
+ 优化种子排序算法，集成覆盖率信息
+ 完善能量调度策略，确保覆盖率驱动的能量分配

#### 刘婕琦
+ 实现更多变异算子（interest、havoc、splice）
+ 集成变异组件与测试执行组件，确保变异后的测试用例正确执行

#### 赵浩博
+ 完善日志记录功能，增加执行速度和覆盖率的详细记录
+ 实现特殊测试用例的保存和分类

#### 刘文浩
+ 完善数据分析脚本，增加统计表格的生成

### 2024-12-10 至 2024-12-17
#### 全体成员
+ 配置并启动 10 个模糊目标的 24 小时模糊测试
+ 监控测试运行情况，确保测试任务按计划进行

### 2024-12-18 至 2024-12-25
#### 邱凯旋
+ 协助完成开发日志和项目文档的整理
+ 最终优化种子排序和能量调度组件

#### 刘婕琦
+ 完成变异组件和环境的最终优化
+ 协助文档编写，确保代码部分描述清晰

#### 赵浩博
+ 完成执行结果监控组件的最终优化
+ 协助文档编写，确保监控功能描述详实

#### 刘文浩
+ 完成评估组件的最终优化和图表生成
+ 完成评估报告的撰写，整理所有统计图表

## 遇到的问题及解决方案
### 问题1：种子排序算法未能有效基于覆盖率进行优先级排序
**描述：**  
在初始实现种子排序组件时，发现现有的排序算法未能有效地根据种子的覆盖率来优先选择测试用例。这导致某些高覆盖率的种子未能及时被优先执行，影响了模糊测试的整体效率和覆盖范围。

**解决方案：**  
引入覆盖率评分机制，通过记录每个种子的执行所覆盖的新代码路径数量，为种子分配一个覆盖率得分，并根据得分对种子进行优先级排序。具体步骤如下：

1. **覆盖率计数：**
    - 集成覆盖率监控模块，记录每个种子执行后新增覆盖的代码路径。
2. **评分算法：**
    - 为每个种子计算覆盖率得分，得分高的种子表示其覆盖了更多的新路径。
3. **排序逻辑：**
    - 根据覆盖率得分对种子队列进行降序排序，确保覆盖率高的种子优先执行。

### 问题2：能量调度算法优化困难
**描述：** 初步实现的能量调度算法在高覆盖率情况下表现不佳，无法有效分配能量，导致测试效率低下。

**解决方案：**

+ 研究并引入基于动态覆盖率反馈的能量调整策略
+ 进行多轮实验，调整算法参数，提高能量分配的灵活性和适应性
+ 与种子排序组件紧密协作，确保覆盖率信息的准确传递

### 问题3：插装程序监控困难
**描述：** 在项目中，我们尝试使用AFL（American Fuzzy Lop）对C++程序进行插装，以收集覆盖率信息。然而，在插装后遇到了困难，难通过Java程序获得覆盖率数据。

**解决方案：**

+ Java与C++的集成：

使用Java来调用C++代码，通过共享内存空间来监控覆盖率执行情况。这种方法允许我们在Java中处理和分析覆盖率数据，从而规避了直接在C++中获取数据的困难。

+ 共享内存机制：

通过共享内存实现Java与C++之间的数据交互。C++程序在运行时将覆盖率信息写入共享内存，Java程序读取这些数据进行处理和分析。

+ 覆盖率数据处理：

C++程序对从共享内存中读取的覆盖率数据进行解析。生成覆盖率报告，帮助识别未覆盖的代码区域，指导进一步的模糊测试。

### 问题4：基于语法/结构的高级变异算子设计困难  
**描述：** 在项目中，我们尝试为XML、JavaScript等结构化文件设计高级变异算子，以提高模糊测试的效率。然而，由于这些文件具有高度结构化的特点，普通的随机变异往往导致无效输入，难以生成覆盖率较高的测试用例。  

**解决方案：**

+ 针对XML的结构化变异  ：

       基于XML的层次化特点，设计结构感知的变异算子。例如，针对标签进行以下操作：  标签替换：将标签名替换为同类的其他标签名。属性变异：修改标签属性的值，添加或删除属性。嵌套调整：随机调整标签的嵌套层次，测试解析器对深层嵌套的处理能力。不破坏结构的删除：删除特定标签或内容的同时，保持XML文件的整体语法结构。

+ 针对JavaScript的语义化变异  ：

设计语义化的变异算子，生成有效但复杂的JavaScript代码。实现变量替换，随机替换变量名为同作用域中的其他变量名。函数嵌套，将现有的表达式或代码块嵌套到一个随机生成的函数中等多个算子。

+ 自动化工具辅助：

利用现有的解析与生成工具（如XML解析器、Esprima等JavaScript解析库）对变异输入进行验证，过滤无效变异结果。通过上述解决方案，我们可以在不破坏输入文件语法和语义的前提下，生成有效的高质量测试用例，从而提升模糊测试的覆盖率和效率。

### 问题5：变异工具类隐藏崩溃的解决
**描述：**  在长时间运行变异测试时，使用删除、切割等变异操作，可能会生成极端的输入数据。这些输入数据不仅会导致被测试目标崩溃，还可能暴露变异工具类本身的稳定性问题，导致工具类发生崩溃或意外中断，影响测试效率和完整性。

**解决方案：**

+ 工具类稳定性增强：  

在工具类中加入严格的输入验证机制，确保所有输入数据（即变异后的数据）在操作前符合预期格式和范围。例如检查变异后的文件是否符合要求，验证文件的最小长度和完整性 。

+ 变异算法优化：  

削弱极端变异操作，限制删除和切割等高破坏性操作的频率。设置变异操作的最大执行比例 ， 使用多种变异操作的组合代替单一的极端操作。例如，在切割后插入新数据，或在删除后替换特定区域，以维持输入数据的完整性。  

### **问题6：处理文件异常时程序中断**
**描述：**在 `EvaluationComponent` 和 `EvaluationTableComponent` 中，当处理指定目录下的 `.txt` 文件时，如果某些文件内容不完整（例如缺少第一行的 `Target` 或最后一行的 `Coverage` 数据），程序会抛出 `NullPointerException` 或 `ArrayIndexOutOfBoundsException`，导致程序中断，无法处理后续文件。这种情况会影响程序的稳定性和完整性，尤其是在处理大量文件时。

**解决方案：**

+ 增强异常处理机制：

在读取文件时添加检查逻辑，确保文件内容符合预期，检查文件是否为空。确保第一行和最后一行的内容存在且格式正确。

+ 记录跳过的文件：

为避免数据丢失或调试困难，可以将跳过的文件记录到日志中

+ 提供用户提示：

处理所有文件后，打印出跳过的文件数量和原因

+ 模拟数据填充：

如果目标是确保所有文件都能参与处理，可以为缺失数据的文件填充默认值（仅限测试场景）

